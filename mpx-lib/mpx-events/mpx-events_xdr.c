/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "mpx-events/mpx-events.h"

bool_t
xdr_MpxEventCode (XDR *xdrs, MpxEventCode *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_taskid_t (XDR *xdrs, taskid_t *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxEventBaseStruct (XDR *xdrs, MpxEventBaseStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->m_code))
		 return FALSE;
	 if (!xdr_taskid_t (xdrs, &objp->m_src))
		 return FALSE;
	 if (!xdr_taskid_t (xdrs, &objp->m_dst))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxExternalTaskEventStruct (XDR *xdrs, MpxExternalTaskEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxJobFinishedEventStruct (XDR *xdrs, MpxJobFinishedEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_job))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxLocalClientEventStruct (XDR *xdrs, MpxLocalClientEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_endPoint);
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_endPoint = IXDR_GET_U_LONG(buf);
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxLocalEndPointEventStruct (XDR *xdrs, MpxLocalEndPointEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_endPoint);
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_endPoint = IXDR_GET_U_LONG(buf);
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxLocalListenerEventStruct (XDR *xdrs, MpxLocalListenerEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->m_fd))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxLocalTaskQueryEventStruct (XDR *xdrs, MpxLocalTaskQueryEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_path, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxPosixMQEventStruct (XDR *xdrs, MpxPosixMQEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_listener))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_listener);
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_listener))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_listener = IXDR_GET_U_LONG(buf);
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_listener))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxPosixMQTaskQueryEventStruct (XDR *xdrs, MpxPosixMQTaskQueryEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_path, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxStartEventStruct (XDR *xdrs, MpxStartEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxStopEventStruct (XDR *xdrs, MpxStopEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTaskQueryEventType (XDR *xdrs, MpxTaskQueryEventType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTaskQueryEventStruct (XDR *xdrs, MpxTaskQueryEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_taskName, ~0))
		 return FALSE;
	 if (!xdr_MpxTaskQueryEventType (xdrs, &objp->m_queryType))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTaskResponseEventStruct (XDR *xdrs, MpxTaskResponseEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_task))
		 return FALSE;
	 if (!xdr_MpxTaskQueryEventType (xdrs, &objp->m_queryType))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp4ClientEventStruct (XDR *xdrs, MpxTcp4ClientEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_endPoint);
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_endPoint = IXDR_GET_U_LONG(buf);
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp4EndPointEventStruct (XDR *xdrs, MpxTcp4EndPointEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_endPoint);
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_endPoint = IXDR_GET_U_LONG(buf);
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp4ListenerEventStruct (XDR *xdrs, MpxTcp4ListenerEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->m_fd))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp4TaskQueryEventStruct (XDR *xdrs, MpxTcp4TaskQueryEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_hostname, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_port, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp6ClientEventStruct (XDR *xdrs, MpxTcp6ClientEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_endPoint);
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_endPoint = IXDR_GET_U_LONG(buf);
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp6EndPointEventStruct (XDR *xdrs, MpxTcp6EndPointEventStruct *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->m_endPoint);
		IXDR_PUT_U_LONG(buf, objp->m_flags);
		IXDR_PUT_U_LONG(buf, objp->m_error);
		IXDR_PUT_U_LONG(buf, objp->m_size);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->m_endPoint))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_error))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->m_size))
				 return FALSE;

		} else {
		objp->m_endPoint = IXDR_GET_U_LONG(buf);
		objp->m_flags = IXDR_GET_U_LONG(buf);
		objp->m_error = IXDR_GET_U_LONG(buf);
		objp->m_size = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_endPoint))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_error))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->m_size))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->m_buffer.m_buffer_val, (u_int *) &objp->m_buffer.m_buffer_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp6ListenerEventStruct (XDR *xdrs, MpxTcp6ListenerEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->m_fd))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTcp6TaskQueryEventStruct (XDR *xdrs, MpxTcp6TaskQueryEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_hostname, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_port, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxTimerEventStruct (XDR *xdrs, MpxTimerEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_task))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_timerStamp))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->m_timer))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxUdp4TaskQueryEventStruct (XDR *xdrs, MpxUdp4TaskQueryEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_hostname, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_port, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxUdp6TaskQueryEventStruct (XDR *xdrs, MpxUdp6TaskQueryEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_hostname, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_port, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxConsumerEventStruct (XDR *xdrs, MpxConsumerEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventBaseStruct (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->m_string, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MpxEventStruct (XDR *xdrs, MpxEventStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_MpxEventCode (xdrs, &objp->m_code))
		 return FALSE;
	switch (objp->m_code) {
	case MpxEventBaseCode:
		 if (!xdr_MpxEventBaseStruct (xdrs, &objp->MpxEventStruct_u.m_EventBasw))
			 return FALSE;
		break;
	case MpxExternalTaskEventCode:
		 if (!xdr_MpxExternalTaskEventStruct (xdrs, &objp->MpxEventStruct_u.m_ExternalTaskEvent))
			 return FALSE;
		break;
	case MpxJobFinishedEventCode:
		 if (!xdr_MpxJobFinishedEventStruct (xdrs, &objp->MpxEventStruct_u.m_JobFinishedEvent))
			 return FALSE;
		break;
	case MpxLocalClientEventCode:
		 if (!xdr_MpxLocalClientEventStruct (xdrs, &objp->MpxEventStruct_u.m_LocalClientEvent))
			 return FALSE;
		break;
	case MpxLocalEndPointEventCode:
		 if (!xdr_MpxLocalEndPointEventStruct (xdrs, &objp->MpxEventStruct_u.m_LocalEndPointEvent))
			 return FALSE;
		break;
	case MpxLocalListenerEventCode:
		 if (!xdr_MpxLocalListenerEventStruct (xdrs, &objp->MpxEventStruct_u.m_LocalListenerEvent))
			 return FALSE;
		break;
	case MpxLocalTaskQueryEventCode:
		 if (!xdr_MpxLocalTaskQueryEventStruct (xdrs, &objp->MpxEventStruct_u.m_LocalTaskQueryEvent))
			 return FALSE;
		break;
	case MpxPosixMQEventCode:
		 if (!xdr_MpxPosixMQEventStruct (xdrs, &objp->MpxEventStruct_u.m_PosixMQEvent))
			 return FALSE;
		break;
	case MpxPosixMQTaskQueryEventCode:
		 if (!xdr_MpxPosixMQTaskQueryEventStruct (xdrs, &objp->MpxEventStruct_u.m_PosixMQTaskQueryEvent))
			 return FALSE;
		break;
	case MpxStartEventCode:
		 if (!xdr_MpxStartEventStruct (xdrs, &objp->MpxEventStruct_u.m_StartEvent))
			 return FALSE;
		break;
	case MpxStopEventCode:
		 if (!xdr_MpxStopEventStruct (xdrs, &objp->MpxEventStruct_u.m_StopEvent))
			 return FALSE;
		break;
	case MpxTaskQueryEventCode:
		 if (!xdr_MpxTaskQueryEventStruct (xdrs, &objp->MpxEventStruct_u.m_TaskQueryEvent))
			 return FALSE;
		break;
	case MpxTaskResponseEventCode:
		 if (!xdr_MpxTaskResponseEventStruct (xdrs, &objp->MpxEventStruct_u.m_TaskResponseEvent))
			 return FALSE;
		break;
	case MpxTcp4ClientEventCode:
		 if (!xdr_MpxTcp4ClientEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp4ClientEvent))
			 return FALSE;
		break;
	case MpxTcp4EndPointEventCode:
		 if (!xdr_MpxTcp4EndPointEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp4EndPointEvent))
			 return FALSE;
		break;
	case MpxTcp4ListenerEventCode:
		 if (!xdr_MpxTcp4ListenerEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp4ListenerEvent))
			 return FALSE;
		break;
	case MpxTcp4TaskQueryEventCode:
		 if (!xdr_MpxTcp4TaskQueryEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp4TaskQueryEvent))
			 return FALSE;
		break;
	case MpxTcp6ClientEventCode:
		 if (!xdr_MpxTcp6ClientEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp6ClientEvent))
			 return FALSE;
		break;
	case MpxTcp6EndPointEventCode:
		 if (!xdr_MpxTcp6EndPointEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp6EndPointEvent))
			 return FALSE;
		break;
	case MpxTcp6ListenerEventCode:
		 if (!xdr_MpxTcp6ListenerEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp6ListenerEvent))
			 return FALSE;
		break;
	case MpxTcp6TaskQueryEventCode:
		 if (!xdr_MpxTcp6TaskQueryEventStruct (xdrs, &objp->MpxEventStruct_u.m_Tcp6TaskQueryEvent))
			 return FALSE;
		break;
	case MpxTimerEventCode:
		 if (!xdr_MpxTimerEventStruct (xdrs, &objp->MpxEventStruct_u.m_TimerEvent))
			 return FALSE;
		break;
	case MpxUdp4TaskQueryEventCode:
		 if (!xdr_MpxUdp4TaskQueryEventStruct (xdrs, &objp->MpxEventStruct_u.m_Udp4TaskQueryEvent))
			 return FALSE;
		break;
	case MpxUdp6TaskQueryEventCode:
		 if (!xdr_MpxUdp6TaskQueryEventStruct (xdrs, &objp->MpxEventStruct_u.m_Udp6TaskQueryEvent))
			 return FALSE;
		break;
	case MpxConsumerEventCode:
		 if (!xdr_MpxConsumerEventStruct (xdrs, &objp->MpxEventStruct_u.m_ConsumerEvent))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
