//    Event Driven Task Multiplexing Library
//    Copyright (C) 2018 Miran Vodnik
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
//    contact: miran.vodnik@siol.net

#include <stdlib.h>
#include <string.h>
#include <uuid/uuid.h>
#include <mpx-core/MpxTaskMultiplexer.h>
#include <mpx-event-queues/MpxEventQueueRepository.h>

namespace mpx
{

/*! creation of single instance of MpxEventQueueRepository
 *
 * this instance is accessed by static member functions of this class
 */
MpxEventQueueRepository* MpxEventQueueRepository::g_mpxEventQueueRepository = new MpxEventQueueRepository ();

/*! Instance initialization
 *
 * Constructor initializes locking object used to synchronize access
 * to dictionary
 */
MpxEventQueueRepository::MpxEventQueueRepository ()
{
	pthread_mutexattr_t attr;

	pthread_mutexattr_init (&attr);
	pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
	pthread_mutex_init (&m_lock, &attr);
}

/*! Instance cleanup
 *
 * all waiting queue names are deallocated by this destructor, dictionary
 * is cleared
 */
MpxEventQueueRepository::~MpxEventQueueRepository ()
{
	mpxset::iterator it;

	for (it = m_mpxset.begin (); it != m_mpxset.end (); ++it)
		free ((void*) it->second);
	m_mpxset.clear ();
}

/*! register event queue - instance method
 *
 * This method performs in the following way:
 * - it synchronizes access to dictionary of waiting queue names
 * - next it checks if task multiplexer referenced by opaque reference id
 * already has associated waiting queue name. If it has, reference to that
 * name is returned
 * - if parameter name references null pointer, this method generates waiting
 * queue name in the form of UUID (universally unique identifier)
 * - name, provided by caller or generated by this method, is finally duplicated
 * using strdup() and saved in dictionary.
 * - reference to duplicated string is then returned to the caller
 *
 * @param id - opaque reference of task multiplexer
 * @param name - name of waiting queue (it should be null)
 * @return **name** - reference to the string of waiting queue name, assigned in
 * the manner described above
 */
const char* MpxEventQueueRepository::_RegisterEventQueue (tskmpx_t id, const char* name)
{
	mpxset::iterator it;

	pthread_mutex_lock (&m_lock);
	if ((it = m_mpxset.find (id)) != m_mpxset.end ())
	{
		pthread_mutex_unlock (&m_lock);
		return it->second;
	}

	char uuidstr [40];
	if (name == 0)
	{
		uuid_t uuid;

		uuidstr [0] = '/';
		uuid_generate (uuid);
		uuid_unparse (uuid, uuidstr + 1);

		name = (const char*) uuidstr;
	}

	if ((name = (const char*) strdup (name)) == 0)
	{
		pthread_mutex_unlock (&m_lock);
		return 0;
	}

	m_mpxset [id] = name;
	pthread_mutex_unlock (&m_lock);
	return name;
}

/*! unregister event queue name - instance method
 *
 * Function performs in the following way:
 * - it synchronizes access to dictionary of waiting queue names
 * - it then checks if waiting queue name associated with task multiplexer,
 * referenced by parameter id, is present in dictionary
 * - if it is, it is deallocated
 *
 * @param id - opaque reference to object representing task multiplexer
 * @return **true** - name has been deallocated, entry with key id has been
 * removed from dictionary
 * @return **false** - waiting queue name has not been deallocated since it
 * has not been found in the dictionary
 */
bool MpxEventQueueRepository::_UnregisterEventQueue (tskmpx_t id)
{
	mpxset::iterator it;

	pthread_mutex_lock (&m_lock);
	if ((it = m_mpxset.find (id)) != m_mpxset.end ())
	{
		free ((void*) it->second);
		m_mpxset.erase (it);
		pthread_mutex_unlock (&m_lock);
		return true;
	}
	pthread_mutex_unlock (&m_lock);
	return false;
}

/*! retrieve event queue name - instance method
 *
 * Function performs in the following way:
 * - it synchronizes access to dictionary of waiting queue names
 * - it then checks if waiting queue name associated with task multiplexer,
 * referenced by parameter id, is present in dictionary
 * - if it is present then the reference to the copy of it is returned to the caller.
 * This copy must be later deallocated by caller
 *
 * @param id - opaque reference to object representing task multiplexer
 * @return **name** - reference to the copy of waiting queue name
 * @return **0** - no entry was found for the key id
 */
const char* MpxEventQueueRepository::_RetrieveEventQueue (tskmpx_t id)
{
	mpxset::iterator it;
	const char* name;
	const char* dname;

	pthread_mutex_unlock (&m_lock);
	name = ((it = m_mpxset.find (id)) != m_mpxset.end ()) ? it->second : 0;
	dname = (name != 0) ? strdup (name) : 0;
	pthread_mutex_unlock (&m_lock);
	return dname;
}

} /* namespace mpx */
